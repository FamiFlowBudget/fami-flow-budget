import React, { createContext, useContext, useState, useEffect } from 'react';
import { supabase } from '@/integrations/supabase/client';
import { useAuth } from '@/hooks/useAuth';
import { Family, UserFamily, FamilyMemberRole, FamilyMemberStatus, Currency } from '@/types/budget';

interface FamilyContextType {
  currentFamily: Family | null;
  userFamilies: UserFamily[];
  loading: boolean;
  switchFamily: (familyId: string) => Promise<void>;
  createFamily: (name: string, currency?: string) => Promise<Family | null>;
  joinFamily: (familyPublicId: string, pin?: string, message?: string) => Promise<boolean>;
  refreshFamilies: () => Promise<void>;
}

const FamilyContext = createContext<FamilyContextType | undefined>(undefined);

export const useFamilyContext = () => {
  const context = useContext(FamilyContext);
  if (!context) {
    throw new Error('useFamilyContext must be used within a FamilyProvider');
  }
  return context;
};

interface FamilyProviderProps {
  children: React.ReactNode;
}

export const FamilyProvider: React.FC<FamilyProviderProps> = ({ children }) => {
  const { user } = useAuth();
  const [currentFamily, setCurrentFamily] = useState<Family | null>(null);
  const [userFamilies, setUserFamilies] = useState<UserFamily[]>([]);
  const [loading, setLoading] = useState(true);

  const loadUserFamilies = async () => {
    if (!user) {
      setUserFamilies([]);
      setCurrentFamily(null);
      setLoading(false);
      return;
    }

    try {
      // Load user's families with family details
      const { data: userFamiliesData, error } = await supabase
        .from('user_families')
        .select(`
          *,
          families (
            id,
            name,
            family_public_id,
            currency,
            timezone,
            invitation_policy,
            created_at,
            updated_at
          )
        `)
        .eq('user_id', user.id)
        .eq('status', 'active');

      if (error) throw error;

      const mappedFamilies = userFamiliesData?.map(uf => ({
        id: uf.id,
        userId: uf.user_id,
        familyId: uf.family_id,
        role: uf.role as FamilyMemberRole,
        status: uf.status as FamilyMemberStatus,
        joinedAt: uf.joined_at,
        family: uf.families ? {
          id: uf.families.id,
          name: uf.families.name,
          familyPublicId: uf.families.family_public_id,
          currency: uf.families.currency as Currency,
          timezone: uf.families.timezone || 'America/Santiago',
          invitationPolicy: typeof uf.families.invitation_policy === 'object' 
            ? {
                ...uf.families.invitation_policy,
                defaultRoleOnInvite: ((uf.families.invitation_policy as any)?.defaultRoleOnInvite === 'editor' || (uf.families.invitation_policy as any)?.defaultRoleOnInvite === 'visitor') 
                  ? (uf.families.invitation_policy as any).defaultRoleOnInvite 
                  : 'editor' as 'editor' | 'visitor'
              } as Family['invitationPolicy']
            : {
                requirePin: false,
              defaultRoleOnInvite: 'editor' as 'editor' | 'visitor',
                tokenExpiryDays: 7,
                allowEditorImports: false,
                allowEditorReports: true
              },
          createdAt: uf.families.created_at,
          updatedAt: uf.families.updated_at
        } : undefined
      })) || [];

      setUserFamilies(mappedFamilies);

      // Get current family from localStorage or use first family
      const savedFamilyId = localStorage.getItem('currentFamilyId');
      let targetFamily = null;

      if (savedFamilyId) {
        const targetUserFamily = mappedFamilies.find(uf => uf.familyId === savedFamilyId);
        targetFamily = targetUserFamily?.family || null;
      }

      if (!targetFamily && mappedFamilies.length > 0) {
        targetFamily = mappedFamilies[0].family;
      }

      setCurrentFamily(targetFamily);
      if (targetFamily) {
        localStorage.setItem('currentFamilyId', targetFamily.id);
      }

    } catch (error) {
      console.error('Error loading user families:', error);
    } finally {
      setLoading(false);
    }
  };

  const switchFamily = async (familyId: string) => {
    const targetUserFamily = userFamilies.find(uf => uf.familyId === familyId);
    if (targetUserFamily?.family) {
      setCurrentFamily(targetUserFamily.family);
      localStorage.setItem('currentFamilyId', familyId);
    }
  };

  const createFamily = async (name: string, currency = 'CLP'): Promise<Family | null> => {
    if (!user) return null;

    try {
      // Create new family - family_public_id is auto-generated by trigger
      const { data: familyData, error: familyError } = await supabase
        .from('families')
        .insert([{
          name,
          currency,
          family_public_id: '', // Will be auto-generated by trigger
          timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
        }])
        .select()
        .single();

      if (familyError) throw familyError;

      // Map the database response to our Family type
      const mappedFamily: Family = {
        id: familyData.id,
        name: familyData.name,
        familyPublicId: familyData.family_public_id,
        currency: familyData.currency as Currency,
        timezone: familyData.timezone,
        invitationPolicy: typeof familyData.invitation_policy === 'object' 
          ? familyData.invitation_policy as Family['invitationPolicy']
          : {
              requirePin: false,
              defaultRoleOnInvite: 'editor' as 'editor' | 'visitor',
              tokenExpiryDays: 7,
              allowEditorImports: false,
              allowEditorReports: true
            },
        createdAt: familyData.created_at,
        updatedAt: familyData.updated_at
      };

      // Add user as admin
      const { error: memberError } = await supabase
        .from('user_families')
        .insert({
          user_id: user.id,
          family_id: familyData.id,
          role: 'admin'
        });

      if (memberError) throw memberError;

      // Set up default categories for the new family
      await supabase.rpc('setup_default_categories_for_user', {
        user_uuid: user.id
      });

      // Refresh families
      await refreshFamilies();

      return mappedFamily;
    } catch (error) {
      console.error('Error creating family:', error);
      return null;
    }
  };

  const joinFamily = async (familyPublicId: string, pin?: string, message?: string): Promise<boolean> => {
    if (!user) return false;

    try {
      // Find family by public ID
      const { data: familyData, error: familyError } = await supabase
        .from('families')
        .select('*')
        .eq('family_public_id', familyPublicId.toUpperCase())
        .single();

      if (familyError || !familyData) {
        throw new Error('Familia no encontrada');
      }

      // Check if PIN is required and valid
      if (familyData.join_pin_hash && pin) {
        const { data: pinResult } = await supabase.rpc('hash_join_pin', { pin });
        if (pinResult !== familyData.join_pin_hash) {
          throw new Error('PIN incorrecto');
        }
      }

      // Create join request
      const { error: requestError } = await supabase
        .from('join_requests')
        .insert({
          family_id: familyData.id,
          requester_user_id: user.id,
          email: user.email,
          message: message || ''
        });

      if (requestError) throw requestError;

      return true;
    } catch (error) {
      console.error('Error joining family:', error);
      return false;
    }
  };

  const refreshFamilies = async () => {
    await loadUserFamilies();
  };

  useEffect(() => {
    loadUserFamilies();
  }, [user]);

  const value: FamilyContextType = {
    currentFamily,
    userFamilies,
    loading,
    switchFamily,
    createFamily,
    joinFamily,
    refreshFamilies
  };

  return (
    <FamilyContext.Provider value={value}>
      {children}
    </FamilyContext.Provider>
  );
};